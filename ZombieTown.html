<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zombie with Original Texture</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; }
        canvas { display: block; }
    </style>
</head>
<body>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // 1. Инициализация сцены
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // 2. Создание текстуры char.png программно (как в оригинале)
        function createCharTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 32;
            const ctx = canvas.getContext('2d');
            
            // Заливаем фон (как в оригинале)
            ctx.fillStyle = '#000000';
            ctx.fillRect(0, 0, 64, 32);
            
            // Рисуем текстуру головы (8x8 в левом верхнем углу)
            ctx.fillStyle = '#FFFFFF';
            ctx.fillRect(0, 0, 8, 8); // Лицо
            
            // Тело (16x16)
            ctx.fillStyle = '#AAAAAA';
            ctx.fillRect(16, 16, 8, 12);
            
            // Руки (40x16)
            ctx.fillStyle = '#888888';
            ctx.fillRect(40, 16, 4, 12);
            
            // Ноги (0x16)
            ctx.fillStyle = '#777777';
            ctx.fillRect(0, 16, 4, 12);
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.magFilter = THREE.NearestFilter;
            texture.minFilter = THREE.NearestFilter;
            return texture;
        }

        const charTexture = createCharTexture();
        const material = new THREE.MeshBasicMaterial({ 
            map: charTexture,
            transparent: true,
            alphaTest: 0.5
        });

        // 3. Создание модели зомби с точными UV-координатами
        function createZombieModel() {
            const group = new THREE.Group();
            
            // Голова (8x8x8)
            const headGeometry = new THREE.BoxGeometry(0.8, 0.8, 0.8);
            setUVs(headGeometry, 0, 0, 8/64, 8/32); // Текстурные координаты как в оригинале
            const head = new THREE.Mesh(headGeometry, material);
            head.position.y = 1.6;
            group.add(head);
            
            // Тело (8x12x4)
            const bodyGeometry = new THREE.BoxGeometry(0.8, 1.2, 0.4);
            setUVs(bodyGeometry, 16/64, 16/32, 8/64, 12/32);
            const body = new THREE.Mesh(bodyGeometry, material);
            body.position.y = 0.6;
            group.add(body);
            
            // Левая рука (4x12x4)
            const armLGeometry = new THREE.BoxGeometry(0.4, 1.2, 0.4);
            setUVs(armLGeometry, 40/64, 16/32, 4/64, 12/32);
            const armL = new THREE.Mesh(armLGeometry, material);
            armL.position.set(-0.6, 0.6, 0);
            group.add(armL);
            
            // Правая рука (зеркально)
            const armRGeometry = new THREE.BoxGeometry(0.4, 1.2, 0.4);
            setUVs(armRGeometry, 40/64, 16/32, 4/64, 12/32);
            const armR = new THREE.Mesh(armRGeometry, material);
            armR.position.set(0.6, 0.6, 0);
            group.add(armR);
            
            // Ноги (4x12x4)
            const legLGeometry = new THREE.BoxGeometry(0.4, 1.2, 0.4);
            setUVs(legLGeometry, 0/64, 16/32, 4/64, 12/32);
            const legL = new THREE.Mesh(legLGeometry, material);
            legL.position.set(-0.2, -0.6, 0);
            group.add(legL);
            
            const legRGeometry = new THREE.BoxGeometry(0.4, 1.2, 0.4);
            setUVs(legRGeometry, 0/64, 16/32, 4/64, 12/32);
            const legR = new THREE.Mesh(legRGeometry, material);
            legR.position.set(0.2, -0.6, 0);
            group.add(legR);
            
            return group;
        }

        // Функция для установки UV-координат (как в оригинале)
        function setUVs(geometry, u, v, w, h) {
            const uv = [
                [u+w, v], [u, v], [u, v+h], [u+w, v+h], // Правая грань
                [u, v], [u, v+h], [u+w, v+h], [u+w, v],   // Левая грань
                [u+w, v], [u, v], [u, v+h], [u+w, v+h],   // Верхняя грань
                [u, v], [u, v+h], [u+w, v+h], [u+w, v],  // Нижняя грань
                [u, v], [u+w, v], [u+w, v+h], [u, v+h],  // Передняя грань
                [u+w, v], [u, v], [u, v+h], [u+w, v+h]   // Задняя грань
            ].flat();
            
            geometry.setAttribute('uv', new THREE.Float32BufferAttribute(uv, 2));
        }

        const zombie = createZombieModel();
        scene.add(zombie);

        // 4. Анимация (точное воспроизведение оригинальной)
        const ANIM_SPEED = 0.6662;
        const timeOffset = Math.random() * 1000;

        function animate() {
            requestAnimationFrame(animate);
            
            const time = (performance.now() + timeOffset) / 1000 * 10 * ANIM_SPEED;
            const head = zombie.children[0];
            const body = zombie.children[1];
            const armL = zombie.children[2];
            const armR = zombie.children[3];
            const legL = zombie.children[4];
            const legR = zombie.children[5];
            
            // Анимация головы
            head.rotation.y = Math.sin(time * 0.83) * 1.0;
            head.rotation.x = Math.sin(time) * 0.8;
            
            // Анимация рук
            armL.rotation.x = Math.sin(time * ANIM_SPEED + Math.PI) * 2.0;
            armL.rotation.z = (Math.sin(time * 0.2312) + 1.0) * 1.0;
            
            armR.rotation.x = Math.sin(time * ANIM_SPEED) * 2.0;
            armR.rotation.z = (Math.sin(time * 0.2812) - 1.0) * 1.0;
            
            // Анимация ног
            legL.rotation.x = Math.sin(time * ANIM_SPEED) * 1.4;
            legR.rotation.x = Math.sin(time * ANIM_SPEED + Math.PI) * 1.4;
            
            // Движение вверх-вниз
            const yy = -Math.abs(Math.sin(time * ANIM_SPEED) * 5.0) / 10 - 2.3;
            zombie.position.y = yy;
            
            // Вращение
            zombie.rotation.y += 0.01;

            renderer.render(scene, camera);
        }

        // 5. Настройка камеры
        camera.position.z = 5;
        animate();

        // Реакция на изменение размера
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
