<!DOCTYPE html>
<html>
<head>
    <title>Zombie Town</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
    </style>
</head>
<body>
    <canvas id="glcanvas" width="800" height="600"></canvas>

    <script>
        const canvas = document.getElementById('glcanvas');
        const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');

        if (!gl) {
            alert('Unable to initialize WebGL. Your browser may not support it.');
        }

        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('Shader compilation error:', gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }

        function createProgram(gl, vertexShader, fragmentShader) {
            const program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error('Program linking error:', gl.getProgramInfoLog(program));
                gl.deleteProgram(program);
                return null;
            }
            return program;
        }

        const vsSource = `
            attribute vec4 aVertexPosition;
            attribute vec2 aTextureCoord;
            uniform mat4 uModelViewMatrix;
            uniform mat4 uProjectionMatrix;
            varying highp vec2 vTextureCoord;
            void main(void) {
                gl_Position = uProjectionMatrix * uModelViewMatrix * aVertexPosition;
                vTextureCoord = aTextureCoord;
            }
        `;

        const fsSource = `
            varying highp vec2 vTextureCoord;
            uniform sampler2D uSampler;
            uniform lowp vec3 uColor;
            void main(void) {
                gl_FragColor = texture2D(uSampler, vTextureCoord) * vec4(uColor, 1.0);
            }
        `;

        const vsSource2D = `
            attribute vec2 aVertexPosition;
            attribute vec2 aTextureCoord;
            uniform mat4 uTransformMatrix;
            varying highp vec2 vTextureCoord;
            void main(void) {
                gl_Position = uTransformMatrix * vec4(aVertexPosition, 0.0, 1.0);
                vTextureCoord = aTextureCoord;
            }
        `;

        const fsSource2D = `
            varying highp vec2 vTextureCoord;
            uniform sampler2D uSampler;
            uniform lowp vec3 uColor;
            void main(void) {
                gl_FragColor = texture2D(uSampler, vTextureCoord) * vec4(uColor, 1.0);
            }
        `;

        const vertexShader = createShader(gl, gl.VERTEX_SHADER, vsSource);
        const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fsSource);
        const shaderProgram = createProgram(gl, vertexShader, fragmentShader);

        const programInfo = {
            program: shaderProgram,
            attribLocations: {
                vertexPosition: gl.getAttribLocation(shaderProgram, 'aVertexPosition'),
                textureCoord: gl.getAttribLocation(shaderProgram, 'aTextureCoord'),
            },
            uniformLocations: {
                projectionMatrix: gl.getUniformLocation(shaderProgram, 'uProjectionMatrix'),
                modelViewMatrix: gl.getUniformLocation(shaderProgram, 'uModelViewMatrix'),
                uSampler: gl.getUniformLocation(shaderProgram, 'uSampler'),
                uColor: gl.getUniformLocation(shaderProgram, 'uColor'),
            },
        };

        const vertexShader2D = createShader(gl, gl.VERTEX_SHADER, vsSource2D);
        const fragmentShader2D = createShader(gl, gl.FRAGMENT_SHADER, fsSource2D);
        const shaderProgram2D = createProgram(gl, vertexShader2D, fragmentShader2D);

        const programInfo2D = {
            program: shaderProgram2D,
            attribLocations: {
                vertexPosition: gl.getAttribLocation(shaderProgram2D, 'aVertexPosition'),
                textureCoord: gl.getAttribLocation(shaderProgram2D, 'aTextureCoord'),
            },
            uniformLocations: {
                transformMatrix: gl.getUniformLocation(shaderProgram2D, 'uTransformMatrix'),
                uSampler: gl.getUniformLocation(shaderProgram2D, 'uSampler'),
                uColor: gl.getUniformLocation(shaderProgram2D, 'uColor'),
            },
        };

        function loadTexture(gl, url) {
            const texture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, texture);

            const level = 0;
            const internalFormat = gl.RGBA;
            const width = 1;
            const height = 1;
            const border = 0;
            const srcFormat = gl.RGBA;
            const srcType = gl.UNSIGNED_BYTE;
            const pixel = new Uint8Array([0, 0, 255, 255]);
            gl.texImage2D(gl.TEXTURE_2D, level, internalFormat, width, height, border, srcFormat, srcType, pixel);

            const image = new Image();
            image.onload = function() {
                gl.bindTexture(gl.TEXTURE_2D, texture);
                gl.texImage2D(gl.TEXTURE_2D, level, internalFormat, srcFormat, srcType, image);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
            };
            image.src = 'res' + url;
            return texture;
        }

        const textures = {
            char: loadTexture(gl, '/char.png'),
            grass: loadTexture(gl, '/grass.png'),
            default: loadTexture(gl, '/default.png'),
            logo: loadTexture(gl, '/logo.png')
        };

        function mat4Perspective(out, fovy, aspect, near, far) {
            const f = 1.0 / Math.tan(fovy / 2);
            out[0] = f / aspect;
            out[1] = 0;
            out[2] = 0;
            out[3] = 0;
            out[4] = 0;
            out[5] = f;
            out[6] = 0;
            out[7] = 0;
            out[8] = 0;
            out[9] = 0;
            out[11] = -1;
            out[12] = 0;
            out[13] = 0;
            out[15] = 0;
            if (far != null && far !== Infinity) {
                const nf = 1 / (near - far);
                out[10] = (far + near) * nf;
                out[14] = (2 * far * near) * nf;
            } else {
                out[10] = -1;
                out[14] = -2 * near;
            }
            return out;
        }

        function mat4Identity(out) {
            out[0] = 1;
            out[1] = 0;
            out[2] = 0;
            out[3] = 0;
            out[4] = 0;
            out[5] = 1;
            out[6] = 0;
            out[7] = 0;
            out[8] = 0;
            out[9] = 0;
            out[10] = 1;
            out[11] = 0;
            out[12] = 0;
            out[13] = 0;
            out[14] = 0;
            out[15] = 1;
            return out;
        }

        function mat4Translate(out, a, v) {
            const x = v[0], y = v[1], z = v[2];
            let a00, a01, a02, a03;
            let a10, a11, a12, a13;
            let a20, a21, a22, a23;

            if (a === out) {
                out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
                out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
                out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
                out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
            } else {
                a00 = a[0]; a01 = a[1]; a02 = a[2]; a03 = a[3];
                a10 = a[4]; a11 = a[5]; a12 = a[6]; a13 = a[7];
                a20 = a[8]; a21 = a[9]; a22 = a[10]; a23 = a[11];

                out[0] = a00; out[1] = a01; out[2] = a02; out[3] = a03;
                out[4] = a10; out[5] = a11; out[6] = a12; out[7] = a13;
                out[8] = a20; out[9] = a21; out[10] = a22; out[11] = a23;

                out[12] = a00 * x + a10 * y + a20 * z + a[12];
                out[13] = a01 * x + a11 * y + a21 * z + a[13];
                out[14] = a02 * x + a12 * y + a22 * z + a[14];
                out[15] = a03 * x + a13 * y + a23 * z + a[15];
            }

            return out;
        }

        function mat4RotateX(out, a, rad) {
            const s = Math.sin(rad);
            const c = Math.cos(rad);
            const a10 = a[4];
            const a11 = a[5];
            const a12 = a[6];
            const a13 = a[7];
            const a20 = a[8];
            const a21 = a[9];
            const a22 = a[10];
            const a23 = a[11];

            if (a !== out) {
                out[0]  = a[0];
                out[1]  = a[1];
                out[2]  = a[2];
                out[3]  = a[3];
                out[12] = a[12];
                out[13] = a[13];
                out[14] = a[14];
                out[15] = a[15];
            }

            out[4] = a10 * c + a20 * s;
            out[5] = a11 * c + a21 * s;
            out[6] = a12 * c + a22 * s;
            out[7] = a13 * c + a23 * s;
            out[8] = a20 * c - a10 * s;
            out[9] = a21 * c - a11 * s;
            out[10] = a22 * c - a12 * s;
            out[11] = a23 * c - a13 * s;
            return out;
        }

        function mat4RotateY(out, a, rad) {
            const s = Math.sin(rad);
            const c = Math.cos(rad);
            const a00 = a[0];
            const a01 = a[1];
            const a02 = a[2];
            const a03 = a[3];
            const a20 = a[8];
            const a21 = a[9];
            const a22 = a[10];
            const a23 = a[11];

            if (a !== out) {
                out[4]  = a[4];
                out[5]  = a[5];
                out[6]  = a[6];
                out[7]  = a[7];
                out[12] = a[12];
                out[13] = a[13];
                out[14] = a[14];
                out[15] = a[15];
            }

            out[0] = a00 * c - a20 * s;
            out[1] = a01 * c - a21 * s;
            out[2] = a02 * c - a22 * s;
            out[3] = a03 * c - a23 * s;
            out[8] = a00 * s + a20 * c;
            out[9] = a01 * s + a21 * c;
            out[10] = a02 * s + a22 * c;
            out[11] = a03 * s + a23 * c;
            return out;
        }

        function mat4RotateZ(out, a, rad) {
            const s = Math.sin(rad);
            const c = Math.cos(rad);
            const a00 = a[0];
            const a01 = a[1];
            const a02 = a[2];
            const a03 = a[3];
            const a10 = a[4];
            const a11 = a[5];
            const a12 = a[6];
            const a13 = a[7];

            if (a !== out) {
                out[8]  = a[8];
                out[9]  = a[9];
                out[10] = a[10];
                out[11] = a[11];
                out[12] = a[12];
                out[13] = a[13];
                out[14] = a[14];
                out[15] = a[15];
            }

            out[0] = a00 * c + a10 * s;
            out[1] = a01 * c + a11 * s;
            out[2] = a02 * c + a12 * s;
            out[3] = a03 * c + a13 * s;
            out[4] = a10 * c - a00 * s;
            out[5] = a11 * c - a01 * s;
            out[6] = a12 * c - a02 * s;
            out[7] = a13 * c - a03 * s;
            return out;
        }

        function mat4Scale(out, a, v) {
            const x = v[0], y = v[1], z = v[2];

            out[0] = a[0] * x;
            out[1] = a[1] * x;
            out[2] = a[2] * x;
            out[3] = a[3] * x;
            out[4] = a[4] * y;
            out[5] = a[5] * y;
            out[6] = a[6] * y;
            out[7] = a[7] * y;
            out[8] = a[8] * z;
            out[9] = a[9] * z;
            out[10] = a[10] * z;
            out[11] = a[11] * z;
            out[12] = a[12];
            out[13] = a[13];
            out[14] = a[14];
            out[15] = a[15];
            return out;
        }

        function mat4Multiply(out, a, b) {
            const a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
            const a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
            const a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
            const a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

            let b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
            out[0] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
            out[1] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
            out[2] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
            out[3] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

            b0 = b[4]; b1 = b[5]; b2 = b[6]; b3 = b[7];
            out[4] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
            out[5] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
            out[6] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
            out[7] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

            b0 = b[8]; b1 = b[9]; b2 = b[10]; b3 = b[11];
            out[8] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
            out[9] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
            out[10] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
            out[11] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

            b0 = b[12]; b1 = b[13]; b2 = b[14]; b3 = b[15];
            out[12] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
            out[13] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
            out[14] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
            out[15] = b0*a03 + b1*a13 + b2*a23 + b3*a33;
            return out;
        }

        function mat4Ortho(out, left, right, bottom, top, near, far) {
            const lr = 1 / (left - right);
            const bt = 1 / (bottom - top);
            const nf = 1 / (near - far);
            out[0] = -2 * lr;
            out[1] = 0;
            out[2] = 0;
            out[3] = 0;
            out[4] = 0;
            out[5] = -2 * bt;
            out[6] = 0;
            out[7] = 0;
            out[8] = 0;
            out[9] = 0;
            out[10] = 2 * nf;
            out[11] = 0;
            out[12] = (left + right) * lr;
            out[13] = (top + bottom) * bt;
            out[14] = (far + near) * nf;
            out[15] = 1;
            return out;
        }

        class Vec3 {
            constructor(x, y, z) {
                this.x = x;
                this.y = y;
                this.z = z;
            }

            interpolateTo(t, p) {
                const xt = this.x + (t.x - this.x) * p;
                const yt = this.y + (t.y - this.y) * p;
                const zt = this.z + (t.z - this.z) * p;
                return new Vec3(xt, yt, zt);
            }

            set(x, y, z) {
                this.x = x;
                this.y = y;
                this.z = z;
            }
        }

        class Vertex {
            constructor(x, y, z, u, v) {
                if (arguments[0] instanceof Vec3) {
                    this.pos = arguments[0];
                    this.u = arguments[1];
                    this.v = arguments[2];
                } else {
                    this.pos = new Vec3(x, y, z);
                    this.u = u;
                    this.v = v;
                }
            }

            remap(u, v) {
                return new Vertex(this.pos, u, v);
            }
        }

        class Polygon {
            constructor(vertices, u0, v0, u1, v1) {
                this.vertices = vertices;
                if (arguments.length > 1) {
                    vertices[0] = vertices[0].remap(u1, v0);
                    vertices[1] = vertices[1].remap(u0, v0);
                    vertices[2] = vertices[2].remap(u0, v1);
                    vertices[3] = vertices[3].remap(u1, v1);
                }
            }

            render(buffers) {
                for (let i = 3; i >= 0; --i) {
                    const v = this.vertices[i];
                    buffers.positions.push(v.pos.x, v.pos.y, v.pos.z);
                    buffers.textureCoords.push(v.u / 64.0, v.v / 32.0);
                }
            }
        }

        class Cube {
            constructor(xTexOffs, yTexOffs) {
                this.xTexOffs = xTexOffs;
                this.yTexOffs = yTexOffs;
                this.x = 0;
                this.y = 0;
                this.z = 0;
                this.xRot = 0;
                this.yRot = 0;
                this.zRot = 0;
            }

            addBox(x0, y0, z0, w, h, d) {
                this.vertices = new Array(8);
                this.polygons = new Array(6);
                const x1 = x0 + w;
                const y1 = y0 + h;
                const z1 = z0 + d;
                const u0 = new Vertex(x0, y0, z0, 0.0, 0.0);
                const u1 = new Vertex(x1, y0, z0, 0.0, 8.0);
                const u2 = new Vertex(x1, y1, z0, 8.0, 8.0);
                const u3 = new Vertex(x0, y1, z0, 8.0, 0.0);
                const l0 = new Vertex(x0, y0, z1, 0.0, 0.0);
                const l1 = new Vertex(x1, y0, z1, 0.0, 8.0);
                const l2 = new Vertex(x1, y1, z1, 8.0, 8.0);
                const l3 = new Vertex(x0, y1, z1, 8.0, 0.0);
                this.vertices[0] = u0;
                this.vertices[1] = u1;
                this.vertices[2] = u2;
                this.vertices[3] = u3;
                this.vertices[4] = l0;
                this.vertices[5] = l1;
                this.vertices[6] = l2;
                this.vertices[7] = l3;
                this.polygons[0] = new Polygon([l1, u1, u2, l2], this.xTexOffs + d + w, this.yTexOffs + d, this.xTexOffs + d + w + d, this.yTexOffs + d + h);
                this.polygons[1] = new Polygon([u0, l0, l3, u3], this.xTexOffs + 0, this.yTexOffs + d, this.xTexOffs + d, this.yTexOffs + d + h);
                this.polygons[2] = new Polygon([l1, l0, u0, u1], this.xTexOffs + d, this.yTexOffs + 0, this.xTexOffs + d + w, this.yTexOffs + d);
                this.polygons[3] = new Polygon([u2, u3, l3, l2], this.xTexOffs + d + w, this.yTexOffs + 0, this.xTexOffs + d + w + w, this.yTexOffs + d);
                this.polygons[4] = new Polygon([u1, u0, u3, u2], this.xTexOffs + d, this.yTexOffs + d, this.xTexOffs + d + w, this.yTexOffs + d + h);
                this.polygons[5] = new Polygon([l0, l1, l2, l3], this.xTexOffs + d + w + d, this.yTexOffs + d, this.xTexOffs + d + w + d + w, this.yTexOffs + d + h);
            }

            setPos(x, y, z) {
                this.x = x;
                this.y = y;
                this.z = z;
            }

            render(buffers) {
                const c = 57.29578;
                const modelViewMatrix = new Array(16);
                mat4Identity(modelViewMatrix);
                mat4Translate(modelViewMatrix, modelViewMatrix, [this.x, this.y, this.z]);
                mat4RotateZ(modelViewMatrix, modelViewMatrix, this.zRot * c * Math.PI / 180);
                mat4RotateY(modelViewMatrix, modelViewMatrix, this.yRot * c * Math.PI / 180);
                mat4RotateX(modelViewMatrix, modelViewMatrix, this.xRot * c * Math.PI / 180);

                const tempPositions = [];
                const tempTextureCoords = [];

                const tempBuffers = {
                    positions: tempPositions,
                    textureCoords: tempTextureCoords
                };

                for (let i = 0; i < this.polygons.length; ++i) {
                    this.polygons[i].render(tempBuffers);
                }

                for (let i = 0; i < tempPositions.length; i += 3) {
                    const vec = [tempPositions[i], tempPositions[i+1], tempPositions[i+2]];
                    const transformed = [
                        modelViewMatrix[0]*vec[0] + modelViewMatrix[4]*vec[1] + modelViewMatrix[8]*vec[2] + modelViewMatrix[12],
                        modelViewMatrix[1]*vec[0] + modelViewMatrix[5]*vec[1] + modelViewMatrix[9]*vec[2] + modelViewMatrix[13],
                        modelViewMatrix[2]*vec[0] + modelViewMatrix[6]*vec[1] + modelViewMatrix[10]*vec[2] + modelViewMatrix[14],
                        modelViewMatrix[3]*vec[0] + modelViewMatrix[7]*vec[1] + modelViewMatrix[11]*vec[2] + modelViewMatrix[15]
                    ];
                    buffers.positions.push(transformed[0], transformed[1], transformed[2]);
                    buffers.textureCoords.push(tempTextureCoords[i/3*2], tempTextureCoords[i/3*2+1]);
                }
            }
        }

        class Zombie {
            constructor(x, y, z) {
                this.timeOffs = Math.random() * 1239813.0;
                this.rot = Math.random() * Math.PI * 2;
                this.speed = 1.0;
                this.rotA = (Math.random() + 1.0) * 0.01;
                this.x = x;
                this.y = y;
                this.z = z;
                this.xo = x;
                this.yo = y;
                this.zo = z;
                this.isDying = false;
                this.deathTimer = 0.0;
                this.fallSpeed = 0.0;
                this.deathRotX = 0.0;
                this.deathRotZ = 0.0;
                this.deathRotSpeedX = 0.0;
                this.deathRotSpeedZ = 0.0;

                this.head = new Cube(0, 0);
                this.head.addBox(-4.0, -8.0, -4.0, 8, 8, 8);
                this.body = new Cube(16, 16);
                this.body.addBox(-4.0, 0.0, -2.0, 8, 12, 4);
                this.arm0 = new Cube(40, 16);
                this.arm0.addBox(-3.0, -2.0, -2.0, 4, 12, 4);
                this.arm0.setPos(-5.0, 2.0, 0.0);
                this.arm1 = new Cube(40, 16);
                this.arm1.addBox(-1.0, -2.0, -2.0, 4, 12, 4);
                this.arm1.setPos(5.0, 2.0, 0.0);
                this.leg0 = new Cube(0, 16);
                this.leg0.addBox(-2.0, 0.0, -2.0, 4, 12, 4);
                this.leg0.setPos(-2.0, 12.0, 0.0);
                this.leg1 = new Cube(0, 16);
                this.leg1.addBox(-2.0, 0.0, -2.0, 4, 12, 4);
                this.leg1.setPos(2.0, 12.0, 0.0);
            }

            tick() {
                this.rot += this.rotA;
                this.rotA *= 0.99;
                this.rotA += (Math.random() - Math.random()) * Math.random() * Math.random() * 0.01;
                if (this.isDying) {
                    this.fallSpeed += 0.1;
                    this.y -= this.fallSpeed;
                    this.deathTimer += 0.1;
                    this.deathRotX += this.deathRotSpeedX;
                    this.deathRotZ += this.deathRotSpeedZ;
                }
                this.xo = this.x;
                this.yo = this.y;
                this.zo = this.z;
            }

            hit() {
                if (!this.isDying) {
                    this.isDying = true;
                    this.deathTimer = 0.0;
                    this.fallSpeed = 0.0;
                    this.deathRotSpeedX = (Math.random() - 0.5) * 10.0;
                    this.deathRotSpeedZ = (Math.random() - 0.5) * 10.0;
                }
            }

            isDead() {
                return this.isDying && this.deathTimer >= 3.0;
            }

            render(a, buffers) {
                const time = Date.now() / 1000 * 10 * this.speed + this.timeOffs;
                const size = 0.058333334;
                const yy = -Math.abs(Math.sin(time * 0.6662)) * 5.0 - 23.0;

                const modelViewMatrix = new Array(16);
                mat4Identity(modelViewMatrix);
                mat4Translate(modelViewMatrix, modelViewMatrix, [
                    this.xo + (this.x - this.xo) * a,
                    this.yo + (this.y - this.yo) * a,
                    this.zo + (this.z - this.zo) * a
                ]);
                mat4Scale(modelViewMatrix, modelViewMatrix, [1.0, -1.0, 1.0]);
                mat4Scale(modelViewMatrix, modelViewMatrix, [size, size, size]);
                mat4Translate(modelViewMatrix, modelViewMatrix, [0.0, yy, 0.0]);
                mat4RotateY(modelViewMatrix, modelViewMatrix, (this.rot * 57.29578 + 180.0) * Math.PI / 180);

                if (this.isDying) {
                    mat4RotateX(modelViewMatrix, modelViewMatrix, this.deathRotX * Math.PI / 180);
                    mat4RotateZ(modelViewMatrix, modelViewMatrix, this.deathRotZ * Math.PI / 180);
                    this.head.yRot = 0.0;
                    this.head.xRot = 0.0;
                    this.arm0.xRot = 0.0;
                    this.arm0.zRot = 0.0;
                    this.arm1.xRot = 0.0;
                    this.arm1.zRot = 0.0;
                    this.leg0.xRot = 0.0;
                    this.leg1.xRot = 0.0;
                } else {
                    this.head.yRot = Math.sin(time * 0.83) * 1.0;
                    this.head.xRot = Math.sin(time) * 0.8;
                    this.arm0.xRot = Math.sin(time * 0.6662 + Math.PI) * 2.0;
                    this.arm0.zRot = (Math.sin(time * 0.2312) + 1.0) * 1.0;
                    this.arm1.xRot = Math.sin(time * 0.6662) * 2.0;
                    this.arm1.zRot = (Math.sin(time * 0.2812) - 1.0) * 1.0;
                    this.leg0.xRot = Math.sin(time * 0.6662) * 1.4;
                    this.leg1.xRot = Math.sin(time * 0.6662 + Math.PI) * 1.4;
                }

                const tempBuffers = {
                    positions: [],
                    textureCoords: []
                };

                this.head.render(tempBuffers);
                this.body.render(tempBuffers);
                this.arm0.render(tempBuffers);
                this.arm1.render(tempBuffers);
                this.leg0.render(tempBuffers);
                this.leg1.render(tempBuffers);

                for (let i = 0; i < tempBuffers.positions.length; i += 3) {
                    const vec = [tempBuffers.positions[i], tempBuffers.positions[i+1], tempBuffers.positions[i+2]];
                    const transformed = [
                        modelViewMatrix[0]*vec[0] + modelViewMatrix[4]*vec[1] + modelViewMatrix[8]*vec[2] + modelViewMatrix[12],
                        modelViewMatrix[1]*vec[0] + modelViewMatrix[5]*vec[1] + modelViewMatrix[9]*vec[2] + modelViewMatrix[13],
                        modelViewMatrix[2]*vec[0] + modelViewMatrix[6]*vec[1] + modelViewMatrix[10]*vec[2] + modelViewMatrix[14],
                        modelViewMatrix[3]*vec[0] + modelViewMatrix[7]*vec[1] + modelViewMatrix[11]*vec[2] + modelViewMatrix[15]
                    ];
                    buffers.positions.push(transformed[0], transformed[1], transformed[2]);
                    buffers.textureCoords.push(tempBuffers.textureCoords[i/3*2], tempBuffers.textureCoords[i/3*2+1]);
                }
            }
        }

        const WORLD_SIZE = 64.0;
        const WORLD_MIN = -WORLD_SIZE;
        const WORLD_MAX = WORLD_SIZE;
        const ZOMBIE_SPAWN_RADIUS = 6.0;
        const ZOMBIE_BOUNDARY = 12.0;
        const ZOMBIE_MIN = -ZOMBIE_BOUNDARY;
        const ZOMBIE_MAX = ZOMBIE_BOUNDARY;

        let zombies = [];
        const random = Math.random;
        let cameraAngleX = 30.0;
        let cameraAngleY = 0.0;
        let lastSpawnTime = 0;
        let score = 0;
        let wave = 1;
        let lastWaveTime = 0;
        let zombiesKilled = 0;
        let zombiesNeededForNextWave = 10;
        let gameStarted = false;
        const noiseRandom = Math.random;
        let isMouseOverButton = false;

        function spawnInitialZombies() {
            const initialZombies = 64 + Math.floor(Math.random() * 37);
            for (let i = 0; i < initialZombies; i++) {
                spawnZombie();
            }
        }

        function spawnZombie() {
            const angle = Math.random() * 2 * Math.PI;
            const radius = Math.random() * ZOMBIE_SPAWN_RADIUS;
            const x = Math.cos(angle) * radius;
            const z = Math.sin(angle) * radius;
            const zombie = new Zombie(x, 0, z);
            zombie.rot = Math.random() * Math.PI * 2;
            zombies.push(zombie);
        }

        const buffers = {
            positions: [],
            textureCoords: [],
            positionBuffer: null,
            textureCoordBuffer: null,
            numVertices: 0
        };

        function initBuffers() {
            buffers.positionBuffer = gl.createBuffer();
            buffers.textureCoordBuffer = gl.createBuffer();
        }

        function updateBuffers() {
            buffers.positions = [];
            buffers.textureCoords = [];

            const platformBuffers = {
                positions: [],
                textureCoords: []
            };

            for (let x = WORLD_MIN; x <= WORLD_MAX; x += 1.0) {
                platformBuffers.positions.push(x, 0.01, WORLD_MIN);
                platformBuffers.textureCoords.push(x/4, WORLD_MIN/4);
                platformBuffers.positions.push(x, 0.01, WORLD_MAX);
                platformBuffers.textureCoords.push(x/4, WORLD_MAX/4);
            }

            for (let z = WORLD_MIN; z <= WORLD_MAX; z += 1.0) {
                platformBuffers.positions.push(WORLD_MIN, 0.01, z);
                platformBuffers.textureCoords.push(WORLD_MIN/4, z/4);
                platformBuffers.positions.push(WORLD_MAX, 0.01, z);
                platformBuffers.textureCoords.push(WORLD_MAX/4, z/4);
            }

            for (let i = 0; i < platformBuffers.positions.length; i += 3) {
                buffers.positions.push(platformBuffers.positions[i], platformBuffers.positions[i+1], platformBuffers.positions[i+2]);
                buffers.textureCoords.push(platformBuffers.textureCoords[i/3*2], platformBuffers.textureCoords[i/3*2+1]);
            }

            for (const zombie of zombies) {
                zombie.render(1.0, buffers);
            }

            buffers.numVertices = buffers.positions.length / 3;

            gl.bindBuffer(gl.ARRAY_BUFFER, buffers.positionBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(buffers.positions), gl.STATIC_DRAW);

            gl.bindBuffer(gl.ARRAY_BUFFER, buffers.textureCoordBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(buffers.textureCoords), gl.STATIC_DRAW);
        }

        function drawScene() {
            gl.clearColor(0.0, 0.0, 0.0, 1.0);
            gl.clearDepth(1.0);
            gl.enable(gl.DEPTH_TEST);
            gl.depthFunc(gl.LEQUAL);
            gl.enable(gl.BLEND);
            gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

            const projectionMatrix = new Array(16);
            mat4Perspective(projectionMatrix, 60 * Math.PI/180, canvas.width / canvas.height, 0.1, 200.0);

            const modelViewMatrix = new Array(16);
            mat4Identity(modelViewMatrix);
            mat4Translate(modelViewMatrix, modelViewMatrix, [0, 0, -15]);
            mat4RotateX(modelViewMatrix, modelViewMatrix, cameraAngleX * Math.PI / 180);
            mat4RotateY(modelViewMatrix, modelViewMatrix, cameraAngleY * Math.PI / 180);

            gl.useProgram(programInfo.program);

            gl.uniformMatrix4fv(programInfo.uniformLocations.projectionMatrix, false, projectionMatrix);
            gl.uniformMatrix4fv(programInfo.uniformLocations.modelViewMatrix, false, modelViewMatrix);

            gl.bindBuffer(gl.ARRAY_BUFFER, buffers.positionBuffer);
            gl.vertexAttribPointer(programInfo.attribLocations.vertexPosition, 3, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(programInfo.attribLocations.vertexPosition);

            gl.bindBuffer(gl.ARRAY_BUFFER, buffers.textureCoordBuffer);
            gl.vertexAttribPointer(programInfo.attribLocations.textureCoord, 2, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(programInfo.attribLocations.textureCoord);

            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, textures.grass);
            gl.uniform1i(programInfo.uniformLocations.uSampler, 0);
            gl.uniform3f(programInfo.uniformLocations.uColor, 1.0, 1.0, 1.0);

            gl.drawArrays(gl.TRIANGLES, 0, buffers.numVertices);
        }

        function renderText(text, x, y, textureName) {
            const CHAR_WIDTH = 16;
            const CHAR_HEIGHT = 16;
            const TEXTURE_SIZE = 128;
            const texelSize = 8.0 / TEXTURE_SIZE;

            const positions = [];
            const textureCoords = [];

            for (let i = 0; i < text.length; i++) {
                const c = text.charCodeAt(i);
                let charId;
                if (c >= 48 && c <= 57) {
                    charId = c - 48;
                } else if (c >= 97 && c <= 122) {
                    charId = c - 97 + 10;
                } else if (c >= 65 && c <= 90) {
                    charId = c - 65 + 10;
                } else if (c === 58) {
                    charId = 36;
                } else if (c === 32) {
                    charId = 37;
                } else if (c === 47) {
                    charId = 38;
                } else if (c === 33) {
                    charId = 39;
                } else {
                    charId = 37;
                }

                if (charId >= 0) {
                    const cx = charId % 16;
                    const cy = Math.floor(charId / 16);
                    const u1 = cx * texelSize;
                    const v1 = cy * texelSize;
                    const u2 = (cx + 1) * texelSize;
                    const v2 = (cy + 1) * texelSize;

                    positions.push(x + i * CHAR_WIDTH, y);
                    textureCoords.push(u1, v1);
                    positions.push(x + i * CHAR_WIDTH, y + CHAR_HEIGHT);
                    textureCoords.push(u1, v2);
                    positions.push(x + i * CHAR_WIDTH + CHAR_WIDTH, y + CHAR_HEIGHT);
                    textureCoords.push(u2, v2);
                    positions.push(x + i * CHAR_WIDTH, y);
                    textureCoords.push(u1, v1);
                    positions.push(x + i * CHAR_WIDTH + CHAR_WIDTH, y + CHAR_HEIGHT);
                    textureCoords.push(u2, v2);
                    positions.push(x + i * CHAR_WIDTH + CHAR_WIDTH, y);
                    textureCoords.push(u2, v1);
                }
            }

            const positionBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);

            const textureCoordBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, textureCoordBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(textureCoords), gl.STATIC_DRAW);

            const transformMatrix = new Array(16);
            mat4Ortho(transformMatrix, 0, canvas.width, canvas.height, 0, -1, 1);

            gl.useProgram(programInfo2D.program);
            gl.uniformMatrix4fv(programInfo2D.uniformLocations.transformMatrix, false, transformMatrix);
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, textures[textureName]);
            gl.uniform1i(programInfo2D.uniformLocations.uSampler, 0);
            gl.uniform3f(programInfo2D.uniformLocations.uColor, 1.0, 1.0, 1.0);

            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.vertexAttribPointer(programInfo2D.attribLocations.vertexPosition, 2, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(programInfo2D.attribLocations.vertexPosition);

            gl.bindBuffer(gl.ARRAY_BUFFER, textureCoordBuffer);
            gl.vertexAttribPointer(programInfo2D.attribLocations.textureCoord, 2, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(programInfo2D.attribLocations.textureCoord);

            gl.drawArrays(gl.TRIANGLES, 0, positions.length / 2);

            gl.deleteBuffer(positionBuffer);
            gl.deleteBuffer(textureCoordBuffer);
        }

        function renderGUI() {
            const projectionMatrix = new Array(16);
            mat4Ortho(projectionMatrix, 0, canvas.width, canvas.height, 0, -1, 1);

            const modelViewMatrix = new Array(16);
            mat4Identity(modelViewMatrix);

            gl.useProgram(programInfo2D.program);
            gl.uniformMatrix4fv(programInfo2D.uniformLocations.transformMatrix, false, projectionMatrix);

            renderText("Score: " + score, 20, 30, "default");
            renderText("Wave: " + wave, 20, 60, "default");
            renderText("Zombies: " + zombies.length, 20, 90, "default");
        }

        function renderLogo() {
            const logoWidth = 232;
            const logoHeight = 36;
            const logoX = (canvas.width - logoWidth) / 2;
            const logoY = 150;

            const positions = [
                logoX, logoY,
                logoX + logoWidth, logoY,
                logoX + logoWidth, logoY + logoHeight,
                logoX, logoY,
                logoX + logoWidth, logoY + logoHeight,
                logoX, logoY + logoHeight
            ];

            const textureCoords = [
                0, 0,
                1, 0,
                1, 1,
                0, 0,
                1, 1,
                0, 1
            ];

            const positionBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);

            const textureCoordBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, textureCoordBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(textureCoords), gl.STATIC_DRAW);

            const transformMatrix = new Array(16);
            mat4Ortho(transformMatrix, 0, canvas.width, canvas.height, 0, -1, 1);

            gl.useProgram(programInfo2D.program);
            gl.uniformMatrix4fv(programInfo2D.uniformLocations.transformMatrix, false, transformMatrix);
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, textures.logo);
            gl.uniform1i(programInfo2D.uniformLocations.uSampler, 0);
            gl.uniform3f(programInfo2D.uniformLocations.uColor, 1.0, 1.0, 1.0);

            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.vertexAttribPointer(programInfo2D.attribLocations.vertexPosition, 2, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(programInfo2D.attribLocations.vertexPosition);

            gl.bindBuffer(gl.ARRAY_BUFFER, textureCoordBuffer);
            gl.vertexAttribPointer(programInfo2D.attribLocations.textureCoord, 2, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(programInfo2D.attribLocations.textureCoord);

            gl.drawArrays(gl.TRIANGLES, 0, 6);

            gl.deleteBuffer(positionBuffer);
            gl.deleteBuffer(textureCoordBuffer);
        }

        function renderNoiseBackground() {
            const positions = [0, 0, canvas.width, 0, canvas.width, canvas.height, 0, canvas.height];
            const positionBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);

            const transformMatrix = new Array(16);
            mat4Ortho(transformMatrix, 0, canvas.width, canvas.height, 0, -1, 1);

            gl.useProgram(programInfo2D.program);
            gl.uniformMatrix4fv(programInfo2D.uniformLocations.transformMatrix, false, transformMatrix);
            gl.uniform3f(programInfo2D.uniformLocations.uColor, 0.0, 0.0, 0.0);

            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.vertexAttribPointer(programInfo2D.attribLocations.vertexPosition, 2, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(programInfo2D.attribLocations.vertexPosition);

            gl.drawArrays(gl.TRIANGLE_FAN, 0, 4);

            gl.deleteBuffer(positionBuffer);

            const pointPositions = [];
            for (let i = 0; i < 200; i++) {
                pointPositions.push(Math.random() * canvas.width, Math.random() * canvas.height);
            }

            const pointPositionBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, pointPositionBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(pointPositions), gl.STATIC_DRAW);

            gl.uniform3f(programInfo2D.uniformLocations.uColor, 0.3, 0.3, 0.3);

            gl.bindBuffer(gl.ARRAY_BUFFER, pointPositionBuffer);
            gl.vertexAttribPointer(programInfo2D.attribLocations.vertexPosition, 2, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(programInfo2D.attribLocations.vertexPosition);

            gl.drawArrays(gl.POINTS, 0, 200);

            gl.deleteBuffer(pointPositionBuffer);
        }

        function renderMenu() {
            gl.clearColor(0.0, 0.0, 0.0, 1.0);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

            const projectionMatrix = new Array(16);
            mat4Ortho(projectionMatrix, 0, canvas.width, canvas.height, 0, -1, 1);

            const modelViewMatrix = new Array(16);
            mat4Identity(modelViewMatrix);

            gl.useProgram(programInfo2D.program);
            gl.uniformMatrix4fv(programInfo2D.uniformLocations.transformMatrix, false, projectionMatrix);

            renderNoiseBackground();
            renderLogo();

            if (isMouseOverButton) {
                renderText("PLAY", 350, 310, "default");
            } else {
                renderText("PLAY", 350, 310, "default");
            }
        }

        function update() {
            const currentTime = Date.now();
            if (currentTime - lastWaveTime > 30000) {
                wave++;
                zombiesNeededForNextWave = 10 + (wave * 5);
                lastWaveTime = currentTime;
                const additionalZombies = 5 + (wave * 3);
                for (let i = 0; i < additionalZombies; i++) {
                    spawnZombie();
                }
            }

            cameraAngleY += 1.0;
            if (cameraAngleY >= 360.0) {
                cameraAngleY = 0.0;
            }

            for (let i = zombies.length - 1; i >= 0; i--) {
                const zombie = zombies[i];
                zombie.tick();
                const baseSpeed = 0.03;
                const speed = baseSpeed + (wave * 0.005);
                const moveX = Math.sin(zombie.rot) * speed;
                const moveZ = Math.cos(zombie.rot) * speed;
                zombie.x += moveX;
                zombie.z += moveZ;

                if (zombie.x < ZOMBIE_MIN) {
                    zombie.x = ZOMBIE_MIN;
                    zombie.rot = Math.random() * Math.PI * 2;
                }
                if (zombie.x > ZOMBIE_MAX) {
                    zombie.x = ZOMBIE_MAX;
                    zombie.rot = Math.random() * Math.PI * 2;
                }
                if (zombie.z < ZOMBIE_MIN) {
                    zombie.z = ZOMBIE_MIN;
                    zombie.rot = Math.random() * Math.PI * 2;
                }
                if (zombie.z > ZOMBIE_MAX) {
                    zombie.z = ZOMBIE_MAX;
                    zombie.rot = Math.random() * Math.PI * 2;
                }

                if (zombie.isDead()) {
                    zombies.splice(i, 1);
                    score += 10 * wave;
                    zombiesKilled++;
                    if (zombiesKilled >= zombiesNeededForNextWave) {
                        wave++;
                        zombiesKilled = 0;
                        zombiesNeededForNextWave = 10 + (wave * 5);
                        lastWaveTime = currentTime;
                        const additionalZombies = 5 + (wave * 3);
                        for (let j = 0; j < additionalZombies; j++) {
                            spawnZombie();
                        }
                    }
                }
            }
        }

        function getMousePos(canvas, evt) {
            const rect = canvas.getBoundingClientRect();
            return {
                x: evt.clientX - rect.left,
                y: evt.clientY - rect.top
            };
        }

        canvas.addEventListener('click', function(evt) {
            if (!gameStarted) {
                const mousePos = getMousePos(canvas, evt);
                if (mousePos.x >= 350 && mousePos.x <= 450 && mousePos.y >= 300 && mousePos.y <= 340) {
                    gameStarted = true;
                    spawnInitialZombies();
                    lastWaveTime = Date.now();
                }
                return;
            }

            const mousePos = getMousePos(canvas, evt);
            for (const zombie of zombies) {
                const screenPos = worldToScreen(zombie.x, zombie.y, zombie.z);
                if (screenPos) {
                    const dist = Math.sqrt(
                        Math.pow(screenPos[0] - mousePos.x, 2) +
                        Math.pow(screenPos[1] - mousePos.y, 2)
                    );
                    if (dist < 50) {
                        zombie.hit();
                        break;
                    }
                }
            }
        });

        canvas.addEventListener('mousemove', function(evt) {
            if (!gameStarted) {
                const mousePos = getMousePos(canvas, evt);
                isMouseOverButton = mousePos.x >= 350 && mousePos.x <= 450 && mousePos.y >= 300 && mousePos.y <= 340;
            }
        });

        function worldToScreen(x, y, z) {
            const projectionMatrix = new Array(16);
            mat4Perspective(projectionMatrix, 60 * Math.PI/180, canvas.width / canvas.height, 0.1, 200.0);

            const modelViewMatrix = new Array(16);
            mat4Identity(modelViewMatrix);
            mat4Translate(modelViewMatrix, modelViewMatrix, [0, 0, -15]);
            mat4RotateX(modelViewMatrix, modelViewMatrix, cameraAngleX * Math.PI / 180);
            mat4RotateY(modelViewMatrix, modelViewMatrix, cameraAngleY * Math.PI / 180);

            const vec = [x, y, z];
            const camera = [
                modelViewMatrix[0]*vec[0] + modelViewMatrix[4]*vec[1] + modelViewMatrix[8]*vec[2] + modelViewMatrix[12],
                modelViewMatrix[1]*vec[0] + modelViewMatrix[5]*vec[1] + modelViewMatrix[9]*vec[2] + modelViewMatrix[13],
                modelViewMatrix[2]*vec[0] + modelViewMatrix[6]*vec[1] + modelViewMatrix[10]*vec[2] + modelViewMatrix[14],
                modelViewMatrix[3]*vec[0] + modelViewMatrix[7]*vec[1] + modelViewMatrix[11]*vec[2] + modelViewMatrix[15]
            ];

            const clip = [
                projectionMatrix[0]*camera[0] + projectionMatrix[4]*camera[1] + projectionMatrix[8]*camera[2] + projectionMatrix[12]*camera[3],
                projectionMatrix[1]*camera[0] + projectionMatrix[5]*camera[1] + projectionMatrix[9]*camera[2] + projectionMatrix[13]*camera[3],
                projectionMatrix[2]*camera[0] + projectionMatrix[6]*camera[1] + projectionMatrix[10]*camera[2] + projectionMatrix[14]*camera[3],
                projectionMatrix[3]*camera[0] + projectionMatrix[7]*camera[1] + projectionMatrix[11]*camera[2] + projectionMatrix[15]*camera[3]
            ];

            if (clip[3] <= 0.0) return null;

            const ndc = [
                clip[0] / clip[3],
                clip[1] / clip[3],
                clip[2] / clip[3]
            ];

            return [
                (ndc[0] + 1.0) * canvas.width / 2.0,
                (1.0 - ndc[1]) * canvas.height / 2.0
            ];
        }

        function main() {
            gl.viewport(0, 0, canvas.width, canvas.height);
            initBuffers();

            function render() {
                if (!gameStarted) {
                    renderMenu();
                } else {
                    update();
                    updateBuffers();
                    drawScene();
                    renderGUI();
                }
                requestAnimationFrame(render);
            }
            requestAnimationFrame(render);
        }

        main();
    </script>
</body>
</html>
